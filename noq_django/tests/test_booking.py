# Generated by CodiumAI
from noq_django.backend.models import Booking
from datetime import datetime
from noq_django.backend.models import Product
from multiprocessing.connection import Client
from noq_django.backend.models import BookingStatus
from noq_django.backend.models import Available
from datetime import timedelta
from marshmallow import ValidationError
from noq_django.backend.models import Region
from noq_django.backend.models import Host


import pytest


class TestBooking:

    # Booking a product with valid data saves the booking and updates availability
    def test_booking_with_valid_data(self):
        # Initialize a Booking object
        booking = Booking()

        # Set the attributes of the Booking object
        booking.start_date = datetime.now()
        booking.product = Product.objects.get(id=1)
        booking.user = Client.objects.get(id=1)
        booking.status = BookingStatus.objects.get(id=1)

        # Save the Booking object
        booking.save()

        # Assert that the booking is saved
        assert Booking.objects.filter(id=booking.id).exists()

        # Assert that availability is updated
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        assert availability.places_left == booking.product.total_places - 1

    # Booking a product with an invalid date raises ValidationError
    def test_booking_with_invalid_date(self):
        # Initialize a Booking object
        booking = Booking()

        # Set the attributes of the Booking object with an invalid date
        booking.start_date = datetime.now() - timedelta(days=1)
        booking.product = Product.objects.get(id=1)
        booking.user = Client.objects.get(id=1)
        booking.status = BookingStatus.objects.get(id=1)

        # Assert that a ValidationError is raised when trying to save the booking
        with pytest.raises(ValidationError):
            booking.save()

    # Booking a product with a male user and woman-only type raises ValidationError
    def test_booking_with_male_user_and_woman_only_type_raises_validation_error(self):
        # Create a male user
        user = Client.objects.create(
            first_name="John",
            last_name="Doe",
            gender="M",
            street="123 Main St",
            postcode="12345",
            city="New York",
            country="USA",
            phone="123-456-7890",
            email="john.doe@example.com",
            unokod="ABC123",
            day_of_birth=datetime.now().date(),
            personnr_lastnr="1234",
            region=Region.objects.create(name="Region"),
            requirements=None,
            last_edit=datetime.now().date(),
        )

        # Create a woman-only product
        product = Product.objects.create(
            name="Product",
            description="Description",
            total_places=10,
            host=Host.objects.create(name="Host", city="City"),
            type="woman-only",
            requirements=None,
        )

        # Try to book the product with the male user
        with pytest.raises(ValidationError):
            Booking.objects.create(
                start_date=datetime.now().date(),
                product=product,
                user=user,
                status=BookingStatus.objects.create(Description="Status"),
            )

    # Booking a product with the same user and date as the current booking does not raise ValidationError
    def test_booking_with_same_user_and_date(self):
        # Create a booking with valid data
        booking = Booking()
        booking.start_date = datetime.now()
        booking.product = Product.objects.get(id=1)
        booking.user = Client.objects.get(id=1)
        booking.status = BookingStatus.objects.get(id=1)
        booking.save()

        # Try to create another booking with the same user and date
        duplicate_booking = Booking()
        duplicate_booking.start_date = booking.start_date
        duplicate_booking.product = booking.product
        duplicate_booking.user = booking.user
        duplicate_booking.status = booking.status

        # Assert that a ValidationError is raised
        with pytest.raises(ValidationError):
            duplicate_booking.save()

        # Assert that the original booking still exists
        assert Booking.objects.filter(id=booking.id).exists()

        # Assert that availability is not updated
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        assert availability.places_left == booking.product.total_places - 1
